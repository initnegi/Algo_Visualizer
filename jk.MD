# Sorting Algorithm Visualizer

An interactive **web application** built with **HTML**, **CSS**, and **JavaScript** to visualize classic sorting algorithms through real-time animations. This project helps users understand the inner workings of sorting techniques by providing step-by-step visual feedback.

---

## Live Demo

Try it out here: [Sorting Visualizer](https://initnegi.github.io/Algo_Visualizer/)

---


<p align="center">  
  <img src="https://github.com/initnegi/Algo_Visualizer/blob/main/images/desktop-sort-visualizer.png" alt="Sorting Visualizer Screenshot" width="600" />  
</p>

---

## Features

* Visualizes 5 popular sorting algorithms:

    * **Bubble Sort**.
    * **Insertion Sort**.
    * **Selection Sort**.
    * **Merge Sort**.
    * **Quick Sort**.

* Adjustable array size and animation speed to customize learning experience
* Real-time animations showing element comparisons, swaps, and sorted states
* Responsive, clean UI designed for clarity and ease of use

---

## Technologies Used

* **HTML5** for semantic structure
* **CSS3** for styling and responsive design
* **Vanilla JavaScript (ES6+)** for DOM manipulation, asynchronous animations, and sorting logic

---

## How to Use

1. Clone the repository:

   ```bash
   git clone https://github.com/initnegi/Algo_Visualizer.git
   ```
2. Open `index.html` in any modern web browser
3. Select a sorting algorithm, choose the array size and animation speed
4. Click **Sort** to watch the algorithm visualize the sorting process

---

## Code Structure

* `app.js`: Controls UI interactions and event handling
* `helper.js`: Contains helper functions for animation timing and DOM manipulation
* `sort-algorithms.js`: Implements the sorting algorithms with asynchronous steps for smooth visualization

---

## Purpose

This project was created to deepen my understanding of sorting algorithms and improve my skills in frontend web development, especially in DOM manipulation and JavaScript.

---

## Future Improvements

* Rewrite the visualizer using **React.js** to leverage component-based architecture and state management
* Add additional sorting algorithms such as Heap Sort, Radix Sort, and Counting Sort
* Implement unit tests and performance benchmarks
* Include detailed algorithm explanations alongside visualizations

---
